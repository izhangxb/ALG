# 队列

先进者先出，这就是典型的“队列”。

队列和栈一样，是一种操作受限的线性数据表结构。

队列可以利用数组实现，也可以利用链表实现。前者称为顺序队列，后者称为链式队列。


## 顺序队列的实现
实现顺序队列需要两个指针，头指针，尾指针，入队时，后移尾指针，出队时，后移头指针，当尾部已满，头部未满时，数据搬移填满前部空间。



## 顺序队列时间复杂度
出栈的时间复杂度为O(1)，入栈的时间复杂度取决于是否会发生数据搬移，当尾部已满，头部还空的时候，会发生一次O(n)的数据搬移，均摊后，
仍为O(1)；


## 循环队列

为了避免普通队列造成的数据搬移，可以采用循环队列的思路。

![循环队列](../../../pic/queue_circle.jpg)

判断队满和队空：
队空：head == tail
队满：(tail+1)%n == head

## 阻塞队列
阻塞队列其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；
如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。

阻塞队列实际上就是一个“生产者 - 消费者模型”。


## 并发队列

阻塞队列多线程时，会存在并发问题。

阻塞队列 + 线程安全

简单做法：入队和出队的时候加锁
高级做法：使用CAS，在入队前，获取tail位置，入队时比较tail是否发生变化，如果否，则允许入队，反之，本次入队失败。出队则是获取head位置，进行cas。

*CAS是一种无锁算法，CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。*

## 线程调度的思考
基于链表的实现方式，可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。
所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。

而基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。
不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。

**对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。**




