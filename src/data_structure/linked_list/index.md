# 链表

## 常见的缓存淘汰策略
1. 先进先出策略 FIFO（First In，First Out）
2. 最少使用策略 LFU （Least Frequently Used）
3. 最近最少使用策略 LRU （Least Recently Used）

## 常见的链表类型

### 单链表
![单链表](../../../pic/single_linked_list.jpg)

结点：数据+后继指针

头结点：记录链表基地址
尾结点：指向空地址Null

![单链表修改](../../../pic/single_add_delete.jpg)


### 循环链表
![循环链表](../../../pic/circle_linked_list.jpg)

循环链表与单链表的区别在于：尾结点的指针指向头结点。
与单链表相比，循环链表的有点事从链尾到链头比较方便，当处理的数据具有环形结构是，特别适合。比如"约瑟夫问题"


### 双链表
![双链表](../../../pic/doubel_linked_list.jpg)

结点：前驱指针 + 数据 + 后继指针
从结构上来看，双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。

原因在于，常见的对于一个结点的操作，无外乎一下两种情况：
1. 删除给定值的结点
2. 删除给定指针的结点

第一种情况下，为了找到该结点，需要从头对链表进行一次时间复杂度为O(n)的遍历；第二种情况，如果是删除操作或者插入到给定结点之前，由于需要找到上一个结点，但是为了找到上一个结点，
同样要进行一次时间复杂度为O(n)的遍历。这时，就能体现出双向链表的优势了。

双向链表的数据结构体现了**空间换时间**的设计思想。

### 双向循环链表
![双链表](../../../pic/doubel_circle_linked_list.jpg)

循环链表 + 双向链表


### 链表VS数组

| 时间复杂度 |链表 |数组  |
|---|-----|-----|
|插入删除| O(1) | O(n)  |
|随机访问|  O(n) | O(1)  |


数组简单易用，由于使用连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，所以访问效率更高。而链表由于不是连续存储，对CPU缓存不够友好，没有办法有效预读。

数组的缺点在于大小固定，占用整块连续内存区间，如果声明数组过大，可能会导致没有足够的内存分配给他，导致 "内存不足 out of memory"，而声明的过小，扩容需要
先申请空间，然后将原数组拷贝过去，非常耗时。而链表天然支持动态扩容。

## 写链表的技巧

1. 理解指针或引用的含义
将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。

2. 警惕指针丢失和内存泄漏
注意插入结点时的操作顺序；
手动管理内存语言中，删除链表结点时，要记得手动释放内存。

3. 利用哨兵简化实现难度
针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。这样代码实现起来就会很繁琐，不简洁，而且也容易因为考虑不全而出错。
因此我们引入"哨兵"的概念，即不携带数据的哨兵结点，"带头链表"

![带头链表](../../../pic/head_link_list.jpg)


不带头链表添加结点：
```$xslt
new_node->next = p->next;
p->next = new_node;

//特殊情况 第一个结点插入
if (head == null) { head = new_node;}
```

不带头链表删除结点：
```$xslt
p->next = p->next->next;

//特殊情况 尾结点插入
if (head->next == null) { head = null;}
```

带头链表添加结点：
```$xslt
new_node->next = p->next;
p->next = new_node;
```

带头链表删除结点：
```$xslt
p->next = p->next->next;
```

可以发现，哨兵结点是不存储数据的。因为哨兵结点一直存在，所以插入第一个结点和插入其他结点，删除最后一个结点和删除其他结点，都可以统一为相同的代码实现逻辑了。

4. 留意边界条件处理
多留意如下边界条件：
 - 如果链表为空时，代码能否正常工作？
 - 如果链表质保函一个结点时，代码能否正常工作？
 - 如果链表只包含两个结点时，代码是否能正常工作？
 - 代码逻辑在处理头结点和尾结点时，是否能正常工作？
 
5. 举例画图，辅助思考

6. 多写多练，没有捷径




 