# 复杂度分析
[TOC]

## 为什么需要复杂度分析
复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。

我们为什么需要复杂度分析？
1. 事后统计法非常依赖测试环境。
2. 事后统计法，测试结构受测试规模影响很大。

因此我们需要一个不用具体测试数据测试，就能粗略估计算法执行效率的方法。

## 大O复杂度表示法
观察可知，所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比.

故提取公式：*T(n) = O(f(n))*

T(n): 代码执行的时间
n: 数据规模的大小
f(n): 每行代码执行的次数总和

由观察可知，当n->无穷大时，公式中的常量，系数，低阶部分并不左右增长趋势，所谓为了简便起见，我们支取最高阶部分即可。


## 时间复杂度分析

时间复杂度的全称是渐进时间复杂度（asymptotic time complexity），表示算法的执行时间与数据规模之间的增长关系。

如何进行时间复杂度分析？
1. 只关注循环次数最多的一段代码
2. 加法法则： 总复杂度等于量级最大的那段代码的复杂度
3. 乘法法则： 嵌套代码的复杂度等于签到内外代码复杂度的乘积


## 常见的时间复杂度：
![常见复杂度谅解](../../pic/常见的复杂度量级.jpg)

大体可以分为两类： 
1. 多项式量级
2. 非多项式量级， 常见的非多项式量级只有两个：2的n次方， n的阶乘

我们把时间复杂度为非多项式量级的算法问题叫作 NP（Non-Deterministic Polynomial，非确定多项式）问题。

当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。因此，关于 NP 时间复杂度我就不展开讲了。我们主要来看几种常见的多项式时间复杂度。

### O(1)
一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。

### O(logn)、O(nlogn)
例子：
```
 i=1;
 while (i <= n)  {
   i = i * 2;
 }
```
例子中，i的取值实际上为一个等比数列，取极限情况， 2的x次方=n, 那么这个x就是代码执行的次数，所以，x=log2(n)
所以，复杂度为O(log2(n))。由于对数是可以转换的，log3(n) = log3(2) * log2(n), 而常量我们是忽略的，所以对数阶的时间复杂度里，我们统一忽略底，表示为O(logn).

### O(m+n)、O(m*n)
当代码的复杂度由两个数据的规模来决定时，不适用加法法则，但乘法法则依然有效。



## 空间复杂度分析
空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。

常见的空间复杂度就是 O(1)、O(n)、O(n2)。


## 常见的复杂度函数图形
![常见的函数复杂度函数图](../../pic/复杂度函数图.jpg)

常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n方)，越高阶复杂度的算法，执行效率越低。


## 复杂度分析的四个具体方面
最好情况时间复杂度，最坏情况时间复杂度，平均情况时间复杂度，均摊时间复杂度。

### 最好，最坏情况时间复杂度
最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。
最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。

### 平均情况时间复杂度
每种情况需要遍历的次数*每种情况发生的概率 = 加权平均值时间复杂度

### 均摊时间复杂度
```
 // array表示一个长度为n的数组
 // 代码中的array.length就等于n
 int[] array = new int[n];
 int count = 0;
 
 void insert(int val) {
    if (count == array.length) {
       int sum = 0;
       for (int i = 0; i < array.length; ++i) {
          sum = sum + array[i];
       }
       array[0] = sum;
       count = 1;
    }

    array[count] = val;
    ++count;
 }
```
平均复杂度：
当前数组的填充状态有0，1，2，3， ...，n 这 n+1中情况，那么每种情况的概率为1/(n+1), 前n中情况遍历次数为1， 最后一种情况遍历次数为n,
所以平均复杂度 = n * (1/(n+1)) * 1 + n * 1/(n+1) = O(1).

摊还分析法：在插入数据的例子中，每一次O(n)的插入操作，都跟随着n-1次O(1)的插入操作，所以把耗时多的那次操作均摊到N-1次耗时少的操作，那么，均摊下来，
每次就是O(1)。

对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，
我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。







