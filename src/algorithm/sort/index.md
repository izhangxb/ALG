# 常见的排序算法

冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序

![排序种类](../../../pic/排序种类.jpg)

## 如何分析一个排序算法

### 算法的执行效率
1. 最好情况、最坏情况、平均情况时间复杂度

2. 时间复杂度的系数、常数 、低阶   
时间复杂度反应的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。但是实际的软件开发中，我们排序的可能是 10 个、100 个、
1000 个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。

3. 比较次数和交换（或移动）次数   
比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。所以，如果我们在分析排序算法的执行效率的时候，
应该把比较次数和交换（或移动）次数也考虑进去。

### 排序算法的内存消耗
算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，这里还引入了一个新的概念，**原地排序（Sorted in place）**。
原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。

### 排序算法的稳定性
仅仅用执行效率和内存消耗来衡量排序算法的好坏是不够的。针对排序算法，还有一个重要的度量指标，稳定性。这个概念是说，如果待排序的序列中存在值相等的元素，
经过排序之后，相等元素之间原有的先后顺序不变。

举例：
电商系统中，给订单排序，要求先按金额，相同金额的按照时间排序。如果采用先排金额，相同金额再按时间排序的做法，实现起来会很复杂。
如果采用先按下单时间排序，然后在对订单按金额做稳定性排序，实现起来就很简洁。

## 冒泡排序

冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。
一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。

![冒泡排序](../../../pic/冒泡排序.jpg)

优化点： 如果某一次没有数据交换，说明已经顺序已经排好，那么则无需继续进行。

冒泡排序只涉及相邻数据的交换，空间复杂度为O(1)，是原地排序算法。

冒泡排序当相邻两个元素大小相等时，不会交换，所以是稳定的排序算法。

时间复杂度：
最佳：数据已经排好序：O(n)
最差：数据倒序排列O(n^2)
平均：O(n^2)

### 冒泡平均复杂度的推导

**有序度**：数组中具有有序关系的元素对的个数。
`有序元素对：a[i] <= a[j], 如果i < j。`

![有序度](../../../pic/有序度.jpg)

对于一个倒序数组，有序度为0. 对于一个倒序数组，有序度为n*(n-1)/2，此时称为**满有序度**。

**逆序度**：与有序度定义相反。
`逆序元素对：a[i] > a[j], 如果i < j。`


冒泡排序包含两个操作原子，比较和交换。每交换一次，有序度就加 1。
不管算法怎么改进，交换次数总是确定的，即为逆序度，也就是n*(n-1)/2–初始有序度。

对n个数据的数组进行冒泡排序：
最坏情况，有序度为0，需要进行n*(n-1)/2 次交换。
最好情况，有序度为n*(n-1)/2，不需要交换。
假设有序度为平均值 n*(n-1)/4，即需要交换n*(n-1)/4次，比较操作肯定要比交换操作多，而复杂度的上限是 O(n2)，所以平均情况下的时间复杂度就是 O(n^2)。


***推导过程不严格，但实用。***


## 插入排序

将数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，
在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。

![插入排序](../../../pic/插入排序.jpg)


插入排序包含两种操作：插入和移动。对于一个给定的序列，移动操作的次数总是固定的，就等于逆序度。

![插入逆序度](../../../pic/插排逆序度.jpg)

为什么呢？如图，满有序度是 n*(n-1)/2=15，初始序列的有序度是 5，所以逆序度是 10。插入排序中，数据移动的个数总和也等于 10=3+3+4。
（其实移动n位，可以看做依次交换了n次）

插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，是一个原地排序算法。

在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。

时间复杂度：
最好情况： 数据已经排好序，由于不需要移动数据，最好为O(n)；
最差情况： 数组倒序，每次插入到最前面，复杂度为O(n^2)；
平均复杂度：在一个数组中插入数据品骏复杂度为O(n)，对于插入排序，相当于循环N次插入操作，即复杂度为O(n^2)

## 选择排序

选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

![选择排序](../../../pic/选择排序.jpg)


选择排序空间复杂度为 O(1)，是一种原地排序算法。

选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n^2)。

选择排序是一种不稳定的排序算法。选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。

## 为什么插入排序要优于冒泡排序


```
    // 冒泡排序中数据的交换操作：
    if (a[j] > a[j+1]) { // 交换
       int tmp = a[j];
       a[j] = a[j+1];
       a[j+1] = tmp;
       flag = true;
    }
    
    // 插入排序中数据的移动操作：
    if (a[j] > value) {
      a[j+1] = a[j];  // 数据移动
    } else {
      break;
    }
```

虽然冒泡排序和插入排序的算法复杂度是一样的，但是从代码可知：冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个，
假设执行一个赋值语句的时间粗略地计为单位时间（unit_time），用冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，所以交换操作总耗时就是 3*K 单位时间。
而插入排序中数据移动操作只需要 K 个单位时间。













