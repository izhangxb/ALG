
# 哈希算法
将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是**哈希算法**，
而通过原始数据映射之后得到的二进制值串就是**哈希值**。

## 哈希算法的要求
1. 从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）；
2. 对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同；
3. 散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；
4. 哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。

## 哈希算法的应用

### 安全加密
MD5，SHA，DES，AES等
重点：第一点是很难根据哈希值反向推导出原始数据，第二点是散列冲突的概率要很小。

为什么理论上是没办法做到完全不冲突的？
**鸽巢原理**（也叫抽屉原理）。如果有 10 个鸽巢，有 11 只鸽子，那肯定有 1 个鸽巢中的鸽子数量多于 1 个，
换句话说就是，肯定有 2 只鸽子在 1 个鸽巢内。

由于哈希算法产生的哈希值的长度是固定且有限的，能表示的数据是有限的，假设为N ，基于鸽巢原理，如果我们对 N+1 个数据求哈希值，
就必然会存在哈希值相同的情况。

### 唯一标识

### 数据校验

### 散列函数
该场景更加关注散列后的值是否能平均分布，散列函数执行的快慢；

### 负载均衡
那如何才能实现一个会话粘滞（session sticky）的负载均衡算法呢？
最直接的方法就是，维护一张映射关系表，这张表的内容是客户端 IP 地址或者会话 ID 与服务器编号的映射关系。
弊端：
1. 如果客户端很多，映射表可能会很大，比较浪费内存空间；
2. 客户端下线、上线，服务器扩容、缩容都会导致映射失效，这样维护映射表的成本就会很大；

我们可以通过哈希算法，对客户端 IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，
最终得到的值就是应该被路由到的服务器编号。


### 数据分片
1. 如何统计“搜索关键词”出现的次数？
为了提高处理的速度，我们用 n 台机器并行处理。我们从搜索记录的日志文件中，依次读出每个搜索关键词，并且通过哈希函数计算哈希值，
然后再跟 n 取模，最终得到的值，就是应该被分配到的机器编号。这样，哈希值相同的搜索关键词就被分配到了同一个机器上。
也就是说，同一个搜索关键词会被分配到同一个机器上。每个机器会分别计算关键词出现的次数，最后合并起来就是最终的结果。

2. 如何快速判断图片是否在图库中？
我们准备 n 台机器，让每台机器只维护某一部分图片对应的散列表。我们每次从图库中读取一个图片，计算唯一标识，然后与机器个数 n 求余取模，
得到的值就对应要分配的机器编号，然后将这个图片的唯一标识和图片路径发往对应的机器构建散列表。当我们要判断一个图片是否在图库中的时候，
我们通过同样的哈希算法，计算这个图片的唯一标识，然后与机器个数 n 求余取模。假设得到的值是 k，那就去编号 k 的机器构建的散列表中查找。

### 分布式存储
借用前面数据分片的思想，即通过哈希算法对数据取哈希值，然后对机器个数取模，这个最终值就是应该存储的缓存机器编号。

但是当有机器扩容时，由于取模操作，导致所有的数据都要重新计算哈希值，然后重新搬移到正确的机器上。这样就可能发生雪崩效应，压垮数据库。

**一致性哈希算法**
假设我们有 k 个机器，数据的哈希值的范围是[0, MAX]。我们将整个范围划分成 m 个小区间（m 远大于 k），每个机器负责 m/k 个小区间。
当有新机器加入的时候，我们就将某几个小区间的数据，从原来的机器中搬移到新的机器中。
这样，既不用全部重新哈希、搬移数据，也保持了各个机器上数据数量的均衡。

[推荐阅读](https://www.jianshu.com/p/570dc8913c20)




